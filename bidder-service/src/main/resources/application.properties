spring.application.name=bidder-service

# This "un-hides" the /actuator/prometheus endpoint
management.endpoints.web.exposure.include=prometheus

# This tells Micrometer to add the data needed for P99 latency graphs
management.metrics.distribution.percentiles-histogram.http.server.requests=true
# Java 21 Virtual Threads (Loom)
spring.threads.virtual.enabled=true

# Kafka Consumer Configuration
spring.kafka.bootstrap-servers=my-cluster-kafka-bootstrap.kafka.svc.cluster.local:9092
spring.kafka.consumer.group-id=bidder-group-10k-qps-test5
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.value.default.type=com.rtb.bidder_service.dto.BidRequest
spring.kafka.consumer.properties.spring.json.trusted.packages=*

# PostgreSQL (JPA) Configuration
spring.datasource.url=jdbc:postgresql://postgres-postgresql.default.svc.cluster.local:5432/postgres
spring.datasource.username=postgres
spring.datasource.password=mysecretpassword
spring.jpa.hibernate.ddl-auto=update

# Redis (Cache) Configuration
# Tell Spring to use Redis for its caching abstraction [4, 5]
spring.cache.type=redis
# The host for Redis service (running in the 'default' namespace)
spring.data.redis.host=redis-master.default.svc.cluster.local
spring.data.redis.port=6379

# Tell the JSON deserializer to IGNORE incoming type headers
# and ONLY use the "spring.json.value.default.type" as defined.
spring.kafka.consumer.properties.spring.json.use.type.headers=false

# Kafka Producer Configuration (for sending bids)
# Tell the producer to serialize our BidResponse objects to JSON
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer

# This maps Java class to a "type ID"
# This lets other services (like our future auction-service)
# know what kind of object this JSON represents.
spring.kafka.producer.properties.spring.json.type.mapping=bidResp:com.rtb.bidder_service.dto.BidResponse